"""
Exit Management Framework
==========================

Systematic exit protocols for all position types:
- Profit taking (mechanical targets)
- Loss limitation (stop losses)
- Time-based exits (DTE management)
- Regime change exits
- Greek-based risk exits
- Volatility environment exits
"""

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from enum import Enum

from .regime_classification import Regime, RegimeMetrics


class ExitTrigger(Enum):
    """Exit trigger types"""
    PROFIT_TARGET = "profit_target"
    STOP_LOSS = "stop_loss"
    TIME_EXIT = "time_exit"
    REGIME_CHANGE = "regime_change"
    GREEK_LIMIT = "greek_limit"
    VOL_ENVIRONMENT = "vol_environment"
    TRAIL_STOP = "trail_stop"
    DEFCON = "defcon"


class ExitUrgency(Enum):
    """Exit urgency levels"""
    ROUTINE = "routine"  # Normal profit/time exit
    URGENT = "urgent"  # Stop loss hit
    IMMEDIATE = "immediate"  # Regime change
    EMERGENCY = "emergency"  # DEFCON alert


@dataclass
class ExitSignal:
    """Exit signal generated by the system"""
    trigger: ExitTrigger
    urgency: ExitUrgency
    reason: str
    recommended_action: str
    timestamp: datetime
    metadata: Dict = None


@dataclass
class ProfitTargets:
    """Profit target configuration by strategy type"""
    strategy_type: str
    target_pct_of_max: float  # 50% = 0.50
    min_hold_days: int
    max_hold_dte: int

    def calculate_target_price(self, entry_credit: float) -> float:
        """Calculate target exit price for credit strategies"""
        # Target is to buy back at X% of max profit
        # If sold for $2.00 credit, target 50% = buy back at $1.00
        return entry_credit * (1.0 - self.target_pct_of_max)

    def calculate_target_profit(self, entry_debit: float) -> float:
        """Calculate target profit for debit strategies"""
        # Target is X% gain on debit paid
        # If paid $3.00 debit, target 100% = sell at $6.00
        return entry_debit * (1.0 + self.target_pct_of_max)


@dataclass
class StopLoss:
    """Stop loss configuration"""
    strategy_type: str  # 'credit' or 'debit'
    multiplier: float  # 2.0 for credit, 0.5 for debit

    def calculate_stop_price(
        self,
        entry_price: float,
        is_credit: bool,
    ) -> float:
        """Calculate stop loss trigger price"""
        if is_credit:
            # Credit: stop if buyback cost = entry credit × 2.0
            return entry_price * self.multiplier
        else:
            # Debit: stop if value drops to entry debit × 0.5
            return entry_price * self.multiplier


@dataclass
class ExitConditions:
    """Current position state for exit evaluation"""

    # Position Details
    strategy_name: str
    is_credit_strategy: bool
    entry_price: float
    current_price: float
    entry_date: datetime
    current_dte: int

    # P&L
    current_pnl: float
    current_pnl_pct: float

    # Regime
    entry_regime: Regime
    current_regime: Regime

    # Greeks
    current_delta: float = 0.0
    current_gamma: float = 0.0
    current_vega: float = 0.0
    current_theta: float = 0.0

    # Volatility
    entry_iv_rank: float = 50.0
    current_iv_rank: float = 50.0
    current_vol_edge: float = 0.0

    # Trail Stop (if active)
    trail_stop_price: Optional[float] = None


class ExitManager:
    """
    Systematic exit management system

    Monitors all exit conditions and generates exit signals.
    """

    # Standard profit targets by strategy type
    PROFIT_TARGETS = {
        'credit_spread': ProfitTargets('credit_spread', 0.55, 7, 21),
        'short_straddle': ProfitTargets('short_straddle', 0.55, 10, 21),
        'short_strangle': ProfitTargets('short_strangle', 0.55, 10, 21),
        'iron_condor': ProfitTargets('iron_condor', 0.50, 7, 21),
        'jade_lizard': ProfitTargets('jade_lizard', 0.60, 5, 14),
        'long_call': ProfitTargets('long_call', 1.50, 0, 999),  # 150% gain
        'long_put': ProfitTargets('long_put', 1.50, 0, 999),
        'debit_spread': ProfitTargets('debit_spread', 0.60, 0, 21),
        'calendar': ProfitTargets('calendar', 0.30, 0, 999),
    }

    # Standard stop losses
    STOP_LOSSES = {
        'credit': StopLoss('credit', 2.0),  # 100% of credit = 2× buyback
        'debit': StopLoss('debit', 0.5),  # 50% loss
    }

    # DTE exit thresholds (non-negotiable)
    DTE_EXITS = {
        'short_premium': 21,
        'long_premium': 30,
        'event_trades': 0,  # Post-event immediate
        'calendar': 999,  # Front month expiry
    }

    def __init__(self):
        self.exit_history: List[ExitSignal] = []

    def evaluate_exit(
        self,
        conditions: ExitConditions,
        profit_target_override: Optional[float] = None,
        stop_loss_override: Optional[float] = None,
    ) -> List[ExitSignal]:
        """
        Evaluate all exit conditions and return triggered signals

        Args:
            conditions: Current position state
            profit_target_override: Optional manual profit target
            stop_loss_override: Optional manual stop loss

        Returns:
            List of ExitSignals (can be multiple triggers)
        """
        signals = []

        # ========================================
        # 1. PROFIT TARGET CHECK
        # ========================================
        profit_signal = self._check_profit_target(
            conditions, profit_target_override
        )
        if profit_signal:
            signals.append(profit_signal)

        # ========================================
        # 2. STOP LOSS CHECK
        # ========================================
        stop_signal = self._check_stop_loss(
            conditions, stop_loss_override
        )
        if stop_signal:
            signals.append(stop_signal)

        # ========================================
        # 3. TRAIL STOP CHECK
        # ========================================
        trail_signal = self._check_trail_stop(conditions)
        if trail_signal:
            signals.append(trail_signal)

        # ========================================
        # 4. TIME-BASED EXIT (DTE)
        # ========================================
        time_signal = self._check_time_exit(conditions)
        if time_signal:
            signals.append(time_signal)

        # ========================================
        # 5. REGIME CHANGE EXIT
        # ========================================
        regime_signal = self._check_regime_exit(conditions)
        if regime_signal:
            signals.append(regime_signal)

        # ========================================
        # 6. GREEK LIMIT EXIT
        # ========================================
        greek_signals = self._check_greek_exits(conditions)
        signals.extend(greek_signals)

        # ========================================
        # 7. VOLATILITY ENVIRONMENT EXIT
        # ========================================
        vol_signal = self._check_vol_exit(conditions)
        if vol_signal:
            signals.append(vol_signal)

        # ========================================
        # 8. DEFCON ALERTS
        # ========================================
        defcon_signal = self._check_defcon_alerts(conditions)
        if defcon_signal:
            signals.append(defcon_signal)

        # Store signals
        self.exit_history.extend(signals)

        return signals

    def _check_profit_target(
        self,
        conditions: ExitConditions,
        override: Optional[float],
    ) -> Optional[ExitSignal]:
        """Check if profit target reached"""

        if override is not None:
            target_pnl_pct = override
        else:
            # Get standard target for strategy
            config = self.PROFIT_TARGETS.get(conditions.strategy_name.lower())
            if config is None:
                return None

            target_pnl_pct = config.target_pct_of_max * 100  # Convert to percentage

            # Check minimum hold time
            days_held = (datetime.now() - conditions.entry_date).days
            if days_held < config.min_hold_days:
                return None  # Haven't held long enough

        # Check if target reached
        if conditions.current_pnl_pct >= target_pnl_pct:
            return ExitSignal(
                trigger=ExitTrigger.PROFIT_TARGET,
                urgency=ExitUrgency.ROUTINE,
                reason=f"Profit target {target_pnl_pct:.0f}% reached ({conditions.current_pnl_pct:.1f}%)",
                recommended_action=f"Close position for ${conditions.current_pnl:,.2f} profit",
                timestamp=datetime.now(),
                metadata={'target_pct': target_pnl_pct, 'actual_pct': conditions.current_pnl_pct},
            )

        return None

    def _check_stop_loss(
        self,
        conditions: ExitConditions,
        override: Optional[float],
    ) -> Optional[ExitSignal]:
        """Check if stop loss triggered"""

        if override is not None:
            stop_pct = override
        else:
            # Use standard stop loss
            stop_config = self.STOP_LOSSES['credit' if conditions.is_credit_strategy else 'debit']

            if conditions.is_credit_strategy:
                # For credit: stop if buyback cost > entry credit × 2
                stop_price = conditions.entry_price * stop_config.multiplier
                if conditions.current_price >= stop_price:
                    stop_triggered = True
                    loss_pct = ((conditions.current_price - conditions.entry_price) / conditions.entry_price) * 100
                else:
                    return None
            else:
                # For debit: stop if value < entry debit × 0.5
                stop_price = conditions.entry_price * stop_config.multiplier
                if conditions.current_price <= stop_price:
                    stop_triggered = True
                    loss_pct = ((conditions.entry_price - conditions.current_price) / conditions.entry_price) * 100
                else:
                    return None

        if stop_triggered:
            return ExitSignal(
                trigger=ExitTrigger.STOP_LOSS,
                urgency=ExitUrgency.URGENT,
                reason=f"Stop loss triggered at -{loss_pct:.1f}%",
                recommended_action=f"Close position immediately to limit loss to ${abs(conditions.current_pnl):,.2f}",
                timestamp=datetime.now(),
                metadata={'loss_pct': loss_pct},
            )

        return None

    def _check_trail_stop(
        self,
        conditions: ExitConditions,
    ) -> Optional[ExitSignal]:
        """Check trailing stop (activated after 30% profit)"""

        # Only activate trail after 30% profit
        if conditions.current_pnl_pct < 30:
            return None

        if conditions.trail_stop_price is None:
            # Initialize trail stop at current value - 25%
            # (This would be set externally, just checking here)
            return None

        # Check if price fell below trail stop
        if conditions.current_price <= conditions.trail_stop_price:
            return ExitSignal(
                trigger=ExitTrigger.TRAIL_STOP,
                urgency=ExitUrgency.URGENT,
                reason=f"Trailing stop triggered at ${conditions.trail_stop_price:.2f}",
                recommended_action="Close position to lock in profits",
                timestamp=datetime.now(),
            )

        return None

    def _check_time_exit(
        self,
        conditions: ExitConditions,
    ) -> Optional[ExitSignal]:
        """Check time-based exits (DTE)"""

        # Determine strategy category
        is_short_premium = any(x in conditions.strategy_name.lower() for x in [
            'short', 'credit', 'iron_condor', 'strangle', 'straddle', 'jade'
        ])

        is_long_premium = any(x in conditions.strategy_name.lower() for x in [
            'long_call', 'long_put', 'debit'
        ])

        # Check mandatory exit DTE
        if is_short_premium and conditions.current_dte <= 21:
            return ExitSignal(
                trigger=ExitTrigger.TIME_EXIT,
                urgency=ExitUrgency.IMMEDIATE,
                reason=f"Mandatory exit at {conditions.current_dte} DTE (short premium gamma risk)",
                recommended_action="Close position immediately",
                timestamp=datetime.now(),
                metadata={'dte': conditions.current_dte},
            )

        if is_long_premium and conditions.current_dte <= 30:
            days_held = (datetime.now() - conditions.entry_date).days
            # Also check 50% time elapsed
            # This is simplified - would need original DTE
            return ExitSignal(
                trigger=ExitTrigger.TIME_EXIT,
                urgency=ExitUrgency.ROUTINE,
                reason=f"Time exit at {conditions.current_dte} DTE (theta acceleration)",
                recommended_action="Close or roll position",
                timestamp=datetime.now(),
                metadata={'dte': conditions.current_dte},
            )

        # Expiration week protocol
        if conditions.current_dte <= 5:
            return ExitSignal(
                trigger=ExitTrigger.TIME_EXIT,
                urgency=ExitUrgency.IMMEDIATE,
                reason=f"Expiration week - {conditions.current_dte} DTE remaining",
                recommended_action="Close all positions (pin risk)",
                timestamp=datetime.now(),
            )

        return None

    def _check_regime_exit(
        self,
        conditions: ExitConditions,
    ) -> Optional[ExitSignal]:
        """Check for regime change exits"""

        # No regime change
        if conditions.entry_regime == conditions.current_regime:
            return None

        from_regime = conditions.entry_regime.numeric_value
        to_regime = conditions.current_regime.numeric_value

        # R1→R2 (VIX >15): Review
        if from_regime == 1 and to_regime == 2:
            return ExitSignal(
                trigger=ExitTrigger.REGIME_CHANGE,
                urgency=ExitUrgency.ROUTINE,
                reason="Regime transition R1→R2 (VIX >15)",
                recommended_action="Review within 1 hour, consider short vol reduction",
                timestamp=datetime.now(),
            )

        # R2→R3 (VIX >20): Reduce exposure
        if from_regime == 2 and to_regime == 3:
            return ExitSignal(
                trigger=ExitTrigger.REGIME_CHANGE,
                urgency=ExitUrgency.URGENT,
                reason="Regime transition R2→R3 (VIX >20)",
                recommended_action="Reduce short vol positions by 50% within 2 hours",
                timestamp=datetime.now(),
            )

        # R3→R4 (VIX >30): Close short vol
        if from_regime == 3 and to_regime == 4:
            return ExitSignal(
                trigger=ExitTrigger.REGIME_CHANGE,
                urgency=ExitUrgency.IMMEDIATE,
                reason="Regime transition R3→R4 (VIX >30)",
                recommended_action="CLOSE ALL SHORT VOL POSITIONS IMMEDIATELY",
                timestamp=datetime.now(),
            )

        # Any→R5: DEFCON 1
        if to_regime == 5:
            return ExitSignal(
                trigger=ExitTrigger.REGIME_CHANGE,
                urgency=ExitUrgency.EMERGENCY,
                reason="REGIME R5 CRISIS MODE - Backwardation detected",
                recommended_action="DEFCON 1: Close everything, shift to long vol",
                timestamp=datetime.now(),
            )

        return None

    def _check_greek_exits(
        self,
        conditions: ExitConditions,
    ) -> List[ExitSignal]:
        """Check Greek limit breaches"""
        signals = []

        # Greek limits per $100k (would scale to account size)
        GREEK_LIMITS = {
            'delta_warning': 25,
            'delta_danger': 40,
            'gamma_warning': 3,
            'gamma_danger': 5,
            'vega_warning': 40,
            'vega_danger': 60,
            'theta_warning': 75,  # $ per day
            'theta_danger': 125,
        }

        # Check Delta
        if abs(conditions.current_delta) > GREEK_LIMITS['delta_danger']:
            signals.append(ExitSignal(
                trigger=ExitTrigger.GREEK_LIMIT,
                urgency=ExitUrgency.IMMEDIATE,
                reason=f"Delta {conditions.current_delta:.1f} exceeds danger limit ±{GREEK_LIMITS['delta_danger']}",
                recommended_action="Hedge with stock/ETF or reduce position",
                timestamp=datetime.now(),
            ))

        # Check Gamma
        if abs(conditions.current_gamma) > GREEK_LIMITS['gamma_danger']:
            signals.append(ExitSignal(
                trigger=ExitTrigger.GREEK_LIMIT,
                urgency=ExitUrgency.IMMEDIATE,
                reason=f"Gamma {conditions.current_gamma:.1f} exceeds danger limit ±{GREEK_LIMITS['gamma_danger']}",
                recommended_action="Close highest gamma positions",
                timestamp=datetime.now(),
            ))

        # Check Vega
        if abs(conditions.current_vega) > GREEK_LIMITS['vega_danger']:
            signals.append(ExitSignal(
                trigger=ExitTrigger.GREEK_LIMIT,
                urgency=ExitUrgency.IMMEDIATE,
                reason=f"Vega {conditions.current_vega:.1f} exceeds danger limit ±{GREEK_LIMITS['vega_danger']}",
                recommended_action="Close highest vega positions",
                timestamp=datetime.now(),
            ))

        return signals

    def _check_vol_exit(
        self,
        conditions: ExitConditions,
    ) -> Optional[ExitSignal]:
        """Check volatility environment exits"""

        # Determine if position is short or long vol
        is_short_vol = any(x in conditions.strategy_name.lower() for x in [
            'short', 'credit', 'iron', 'strangle', 'straddle', 'jade'
        ])

        is_long_vol = any(x in conditions.strategy_name.lower() for x in [
            'long_straddle', 'long_strangle', 'backspread'
        ])

        # Short vol exits
        if is_short_vol:
            # Exit if IV Rank drops below 30%
            if conditions.current_iv_rank < 30:
                return ExitSignal(
                    trigger=ExitTrigger.VOL_ENVIRONMENT,
                    urgency=ExitUrgency.ROUTINE,
                    reason=f"IV Rank dropped to {conditions.current_iv_rank:.1f}% (below 30%)",
                    recommended_action="Close short vol position (edge eroded)",
                    timestamp=datetime.now(),
                )

            # Exit if vol edge < 10%
            if conditions.current_vol_edge < 10:
                return ExitSignal(
                    trigger=ExitTrigger.VOL_ENVIRONMENT,
                    urgency=ExitUrgency.ROUTINE,
                    reason=f"Vol edge dropped to {conditions.current_vol_edge:.1f}% (below 10%)",
                    recommended_action="Close position (insufficient edge)",
                    timestamp=datetime.now(),
                )

        # Long vol exits
        if is_long_vol:
            # Exit if IV Rank rises above 70%
            if conditions.current_iv_rank > 70:
                return ExitSignal(
                    trigger=ExitTrigger.VOL_ENVIRONMENT,
                    urgency=ExitUrgency.ROUTINE,
                    reason=f"IV Rank rose to {conditions.current_iv_rank:.1f}% (above 70%)",
                    recommended_action="Take profit on long vol position",
                    timestamp=datetime.now(),
                )

            # Exit if vol edge > 25%
            if conditions.current_vol_edge > 25:
                return ExitSignal(
                    trigger=ExitTrigger.VOL_ENVIRONMENT,
                    urgency=ExitUrgency.ROUTINE,
                    reason=f"Vol edge expanded to {conditions.current_vol_edge:.1f}% (above 25%)",
                    recommended_action="Take profit (vol spike achieved)",
                    timestamp=datetime.now(),
                )

        return None

    def _check_defcon_alerts(
        self,
        conditions: ExitConditions,
    ) -> Optional[ExitSignal]:
        """Check DEFCON emergency alerts"""

        # DEFCON 1: VIX >50
        if hasattr(conditions, 'vix_level'):
            if conditions.vix_level > 50:
                return ExitSignal(
                    trigger=ExitTrigger.DEFCON,
                    urgency=ExitUrgency.EMERGENCY,
                    reason="DEFCON 1: VIX >50",
                    recommended_action="CLOSE ALL POSITIONS WITHIN 15 MINUTES",
                    timestamp=datetime.now(),
                )

        # DEFCON 1: Daily P&L down >10%
        # (Would need portfolio-level data)

        # Flash crash detection would go here

        return None


def calculate_exit_signal(conditions: ExitConditions) -> List[ExitSignal]:
    """
    Convenience function for one-off exit evaluation

    Args:
        conditions: ExitConditions object

    Returns:
        List of ExitSignals
    """
    manager = ExitManager()
    return manager.evaluate_exit(conditions)
