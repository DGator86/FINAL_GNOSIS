"""Enhanced Trade Agent v3 with Multi-Timeframe Strategy Generation.

Generates dynamic trading strategies based on Composer decisions,
with timeframe-specific risk parameters and exit strategies.

.. deprecated:: v3.0
    This is an ADVANCED version for multi-timeframe strategy generation.
    The canonical version is TradeAgentV1 which is used in production pipelines.
    
    Use this version only for:
    - Multi-timeframe strategy generation
    - Advanced exit strategy management
    - Trailing stop configurations
    
    To use in pipeline, explicitly import:
        from trade.trade_agent_v3 import TradeAgentV3
        
Version History:
- v1: Basic trade idea generation (CANONICAL/DEFAULT)
- v2: Universe-wide optimization with CVXPY (experimental)
- v3: Multi-timeframe strategy with advanced exits (advanced)
"""

from __future__ import annotations

import os
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from loguru import logger

from agents.composer.composer_agent_v2 import ComposerDecision
from schemas.core_schemas import DirectionEnum, TradeIdea


@dataclass
class TradeStrategy:
    """Complete trading strategy generated by Trade Agent."""

    symbol: str
    direction: str  # 'LONG' or 'SHORT'
    entry_price: float
    quantity: int

    # Exit parameters
    stop_loss_price: float
    take_profit_price: float
    trailing_stop_config: Dict[str, float]

    # Time-based exits
    timeframe: str  # Dominant timeframe
    max_hold_time: timedelta
    min_hold_time: timedelta

    # Risk metrics
    risk_amount: float
    reward_amount: float
    risk_reward_ratio: float
    position_size_pct: float

    # Metadata
    confidence: float
    reasoning: str
    timestamp: datetime

    # Asset Class
    asset_class: str = "equity"  # 'equity' or 'option'

    # Option Details (if asset_class == 'option')
    option_symbol: Optional[str] = None
    strike: Optional[float] = None
    expiration: Optional[datetime] = None
    option_type: Optional[str] = None  # 'call' or 'put'


class TradeAgentV3:
    """Enhanced Trade Agent with dynamic strategy generation.

    Generates strategies based on Composer decisions with:
    - Dynamic stop-loss/take-profit by timeframe
    - Trailing stop configuration
    - Time-based exit rules
    - Position sizing based on confidence
    - Options strategy generation (Long Call/Put)
    """

    # Timeframe-specific risk parameters
    TIMEFRAME_RISK = {
        "1Min": {
            "stop_loss_pct": 0.005,  # 0.5%
            "take_profit_pct": 0.015,  # 1.5%
            "trailing_stop_pct": 0.003,
            "trailing_activation": 0.007,
            "max_hold_hours": 0.5,
            "min_hold_minutes": 5,
        },
        "5Min": {
            "stop_loss_pct": 0.01,  # 1%
            "take_profit_pct": 0.03,  # 3%
            "trailing_stop_pct": 0.005,
            "trailing_activation": 0.015,
            "max_hold_hours": 2,
            "min_hold_minutes": 15,
        },
        "15Min": {
            "stop_loss_pct": 0.015,  # 1.5%
            "take_profit_pct": 0.045,  # 4.5%
            "trailing_stop_pct": 0.008,
            "trailing_activation": 0.02,
            "max_hold_hours": 4,
            "min_hold_minutes": 30,
        },
        "30Min": {
            "stop_loss_pct": 0.02,  # 2%
            "take_profit_pct": 0.06,  # 6%
            "trailing_stop_pct": 0.01,
            "trailing_activation": 0.025,
            "max_hold_hours": 8,
            "min_hold_minutes": 60,
        },
        "1Hour": {
            "stop_loss_pct": 0.025,  # 2.5%
            "take_profit_pct": 0.075,  # 7.5%
            "trailing_stop_pct": 0.012,
            "trailing_activation": 0.03,
            "max_hold_hours": 16,
            "min_hold_minutes": 120,
        },
        "4Hour": {
            "stop_loss_pct": 0.03,  # 3%
            "take_profit_pct": 0.09,  # 9%
            "trailing_stop_pct": 0.015,
            "trailing_activation": 0.04,
            "max_hold_hours": 48,
            "min_hold_minutes": 240,
        },
        "1Day": {
            "stop_loss_pct": 0.04,  # 4%
            "take_profit_pct": 0.12,  # 12%
            "trailing_stop_pct": 0.02,
            "trailing_activation": 0.05,
            "max_hold_hours": 120,  # 5 days
            "min_hold_minutes": 480,  # 8 hours
        },
    }

    def __init__(self, config: Optional[Dict] = None, options_adapter: Optional[Any] = None):
        """Initialize Trade Agent.

        Args:
            config: Configuration dictionary
            options_adapter: Adapter for fetching options chain
        """
        self.config = config or {}
        self.options_adapter = options_adapter

        env_max_pct = os.getenv("MAX_POSITION_PCT_PER_TRADE")
        env_base_pct = os.getenv("BASE_POSITION_PCT_PER_TRADE")
        env_min_shares = os.getenv("MIN_SHARES_PER_TRADE")
        env_min_dollars = os.getenv("MIN_DOLLARS_PER_TRADE")

        self.max_position_size_pct = float(
            env_max_pct
            or self.config.get("max_position_size_pct")
            or 0.02
        )
        self.base_position_size_pct = float(
            env_base_pct
            or self.config.get("base_position_size_pct")
            or self.max_position_size_pct
        )
        self.max_portfolio_risk_pct = self.config.get("max_portfolio_risk_pct", 0.02)  # 2% max risk
        self.min_shares_per_trade = int(
            env_min_shares or self.config.get("min_shares_per_trade", 1)
        )
        self.min_dollars_per_trade = float(
            env_min_dollars or self.config.get("min_dollars_per_trade", 0)
        )

        # Options configuration
        self.prefer_options = self.config.get("prefer_options", False)
        self.min_dte = self.config.get("min_dte", 30)
        self.max_dte = self.config.get("max_dte", 60)
        self.target_delta = self.config.get("target_delta", 0.40)

        logger.info(f"TradeAgentV3 initialized (options_enabled={bool(options_adapter)})")

    def generate_strategy(
        self,
        composer_decision: ComposerDecision,
        current_price: float,
        available_capital: float,
        timestamp: datetime,
    ) -> Optional[TradeStrategy]:
        """Generate trading strategy from Composer decision.

        Args:
            composer_decision: Decision from ComposerAgent
            current_price: Current market price
            available_capital: Available capital for trading
            timestamp: Strategy generation timestamp

        Returns:
            TradeStrategy or None if no strategy warranted
        """
        # Check if we should trade
        if not composer_decision.go_signal:
            logger.info(f"No trade for {composer_decision.symbol}: go_signal=False")
            return None

        if composer_decision.predicted_direction == "NEUTRAL":
            logger.info(f"No trade for {composer_decision.symbol}: NEUTRAL direction")
            return None

        # Try to generate options strategy if enabled and appropriate
        if self.prefer_options and self.options_adapter:
            try:
                options_strategy = self._generate_options_strategy(
                    composer_decision, current_price, available_capital, timestamp
                )
                if options_strategy:
                    return options_strategy
            except Exception as e:
                logger.error(f"Failed to generate options strategy: {e}")
                # Fallback to equity

        # Get timeframe-specific risk parameters
        timeframe = composer_decision.predicted_timeframe
        risk_params = self.TIMEFRAME_RISK.get(timeframe, self.TIMEFRAME_RISK["1Hour"])

        # Calculate position size based on confidence
        # Higher confidence = larger position (up to max)
        confidence_multiplier = composer_decision.confidence
        position_size_pct = self.base_position_size_pct * (1 + confidence_multiplier)
        position_size_pct = min(position_size_pct, self.max_position_size_pct)

        quantity, sizing_reason = self._calculate_equity_quantity(
            symbol=composer_decision.symbol,
            current_price=current_price,
            available_capital=available_capital,
            position_size_pct=position_size_pct,
        )

        if quantity < 1:
            reason = sizing_reason or "calculated quantity below minimum"
            logger.warning(
                "Skipping {symbol}: {reason} (price={price}, equity={equity}, budget_pct={pct:.4f})",
                symbol=composer_decision.symbol,
                reason=reason,
                price=current_price,
                equity=available_capital,
                pct=position_size_pct,
            )
            return None

        # Calculate entry and exit prices
        entry_price = current_price

        # Direction-specific calculations
        is_long = composer_decision.predicted_direction == "LONG"
        direction_multiplier = 1 if is_long else -1

        # Stop-loss and take-profit
        stop_loss_price = entry_price * (1 - (risk_params["stop_loss_pct"] * direction_multiplier))
        take_profit_price = entry_price * (
            1 + (risk_params["take_profit_pct"] * direction_multiplier)
        )

        # Trailing stop configuration
        trailing_stop_config = {
            "enabled": True,
            "trail_pct": risk_params["trailing_stop_pct"],
            "activation_pct": risk_params["trailing_activation"],
            "initial_stop": stop_loss_price,
        }

        # Time-based exits
        max_hold_time = timedelta(hours=risk_params["max_hold_hours"])
        min_hold_time = timedelta(minutes=risk_params["min_hold_minutes"])

        # Risk metrics
        risk_amount = abs(entry_price - stop_loss_price) * quantity
        reward_amount = abs(take_profit_price - entry_price) * quantity
        risk_reward_ratio = reward_amount / risk_amount if risk_amount > 0 else 0

        # Build reasoning
        reasoning = (
            f"{composer_decision.predicted_direction} EQUITY signal | "
            f"TF={timeframe} | conf={composer_decision.confidence:.1%} | "
            f"R:R={risk_reward_ratio:.1f} | "
            f"size={position_size_pct:.1%} of capital"
        )

        strategy = TradeStrategy(
            symbol=composer_decision.symbol,
            direction=composer_decision.predicted_direction,
            entry_price=entry_price,
            quantity=quantity,
            stop_loss_price=stop_loss_price,
            take_profit_price=take_profit_price,
            trailing_stop_config=trailing_stop_config,
            timeframe=timeframe,
            max_hold_time=max_hold_time,
            min_hold_time=min_hold_time,
            risk_amount=risk_amount,
            reward_amount=reward_amount,
            risk_reward_ratio=risk_reward_ratio,
            position_size_pct=position_size_pct,
            confidence=composer_decision.confidence,
            reasoning=reasoning,
            timestamp=timestamp,
            asset_class="equity",
        )

        logger.info(
            f"Generated EQUITY strategy for {composer_decision.symbol} | "
            f"{composer_decision.predicted_direction} | qty={quantity} | "
            f"SL=${stop_loss_price:.2f} | TP=${take_profit_price:.2f} | "
            f"R:R={risk_reward_ratio:.1f}"
        )

        return strategy

    def _generate_options_strategy(
        self,
        composer_decision: ComposerDecision,
        current_price: float,
        available_capital: float,
        timestamp: datetime,
    ) -> Optional[TradeStrategy]:
        """Generate options trading strategy."""
        from gnosis.utils.option_utils import OptionUtils

        symbol = composer_decision.symbol
        direction = composer_decision.predicted_direction

        # Determine option type
        option_type = "call" if direction == "LONG" else "put"

        # Get options chain
        chain = self.options_adapter.get_chain(symbol, timestamp)
        if not chain:
            logger.warning(f"No options chain for {symbol}, falling back to equity")
            return None

        # Filter by expiration (DTE)
        target_min_date = timestamp + timedelta(days=self.min_dte)
        target_max_date = timestamp + timedelta(days=self.max_dte)

        valid_expirations = sorted(
            list(
                set(
                    c.expiration
                    for c in chain
                    if target_min_date <= c.expiration <= target_max_date
                )
            )
        )

        if not valid_expirations:
            logger.warning(
                f"No expirations found between {self.min_dte}-{self.max_dte} days for {symbol}"
            )
            return None

        # Select best expiration (closest to middle of range)
        target_date = timestamp + timedelta(days=(self.min_dte + self.max_dte) / 2)
        best_expiration = min(valid_expirations, key=lambda x: abs((x - target_date).days))

        # Filter contracts for this expiration and type
        contracts = [
            c for c in chain if c.expiration == best_expiration and c.option_type == option_type
        ]

        if not contracts:
            return None

        # Select strike based on Delta
        # For calls: delta is positive (0 to 1). Target e.g. 0.40
        # For puts: delta is negative (-1 to 0). Target e.g. -0.40
        target_delta_val = self.target_delta if option_type == "call" else -self.target_delta

        # Find contract with closest delta
        best_contract = min(contracts, key=lambda c: abs(c.delta - target_delta_val))

        # Validate liquidity
        if best_contract.open_interest < 100 or best_contract.volume < 10:
            logger.warning(f"Selected option {best_contract.symbol} has low liquidity")
            return None

        # Calculate position size
        # Options are leveraged, so we might want to risk less capital raw,
        # but for now we use the same risk % of portfolio
        confidence_multiplier = composer_decision.confidence
        position_size_pct = self.base_position_size_pct * (1 + confidence_multiplier)
        position_size_pct = min(position_size_pct, self.max_position_size_pct)

        position_value = available_capital * position_size_pct
        contract_price = best_contract.ask or best_contract.last

        if contract_price <= 0:
            return None

        # 1 contract = 100 shares
        cost_per_contract = contract_price * 100
        quantity = int(position_value / cost_per_contract)

        if quantity < 1:
            logger.warning(
                f"Options sizing below minimum for {symbol}: cost/contract=${cost_per_contract:.2f}, "
                f"position_budget=${position_value:.2f}"
            )
            return None

        # Risk management for options
        # Stop loss on the OPTION price, not underlying
        # Typically wider stops for options due to volatility
        stop_loss_pct = 0.20  # 20% stop loss on premium
        take_profit_pct = 0.50  # 50% take profit on premium

        entry_price = contract_price
        stop_loss_price = entry_price * (1 - stop_loss_pct)
        take_profit_price = entry_price * (1 + take_profit_pct)

        # Risk metrics
        risk_amount = (entry_price - stop_loss_price) * 100 * quantity
        reward_amount = (take_profit_price - entry_price) * 100 * quantity
        risk_reward_ratio = reward_amount / risk_amount if risk_amount > 0 else 0

        reasoning = (
            f"{direction} OPTION signal | {best_contract.symbol} | "
            f"Exp={best_expiration.strftime('%Y-%m-%d')} | "
            f"Strike={best_contract.strike} | Delta={best_contract.delta:.2f} | "
            f"R:R={risk_reward_ratio:.1f}"
        )

        # Generate OCC symbol if not present
        occ_symbol = best_contract.symbol
        if len(occ_symbol) < 15:  # Likely not full OCC
            occ_symbol = OptionUtils.generate_occ_symbol(
                symbol, best_expiration, option_type, best_contract.strike
            )

        strategy = TradeStrategy(
            symbol=symbol,
            direction=direction,
            entry_price=entry_price,
            quantity=quantity,
            stop_loss_price=stop_loss_price,
            take_profit_price=take_profit_price,
            trailing_stop_config={
                "enabled": False
            },  # Harder to trail options accurately without live greeks
            timeframe=composer_decision.predicted_timeframe,
            max_hold_time=timedelta(days=10),  # Options held longer?
            min_hold_time=timedelta(minutes=30),
            risk_amount=risk_amount,
            reward_amount=reward_amount,
            risk_reward_ratio=risk_reward_ratio,
            position_size_pct=position_size_pct,
            confidence=composer_decision.confidence,
            reasoning=reasoning,
            timestamp=timestamp,
            asset_class="option",
            option_symbol=occ_symbol,
            strike=best_contract.strike,
            expiration=best_expiration,
            option_type=option_type,
        )

        logger.info(
            f"Generated OPTION strategy for {symbol} | {occ_symbol} | "
            f"Qty={quantity} | Cost=${cost_per_contract:.2f} | "
            f"Delta={best_contract.delta:.2f}"
        )

        return strategy

    def _calculate_equity_quantity(
        self,
        symbol: str,
        current_price: float,
        available_capital: float,
        position_size_pct: float,
    ) -> tuple[int, str | None]:
        """Calculate share quantity while enforcing minimum sizing.

        Returns (quantity, reason). Quantity of 0 indicates a skip with `reason` explaining why.
        """

        if current_price <= 0:
            return 0, f"invalid current price {current_price}"

        max_position_value = available_capital * position_size_pct

        if max_position_value < self.min_dollars_per_trade:
            return 0, (
                f"position budget ${max_position_value:.2f} below min_dollars_per_trade "
                f"${self.min_dollars_per_trade:.2f}"
            )

        min_cost = current_price * max(1, self.min_shares_per_trade)
        if max_position_value < min_cost:
            if available_capital >= min_cost:
                logger.info(
                    f"Budget below preferred size for {symbol} (budget=${max_position_value:.2f}, "
                    f"required=${min_cost:.2f}); bumping to minimum {self.min_shares_per_trade} share",
                )
                return max(1, self.min_shares_per_trade), None

            return 0, (
                f"insufficient capital for minimum {self.min_shares_per_trade} shares "
                f"(price=${current_price:.2f}, budget=${max_position_value:.2f}, required=${min_cost:.2f})"
            )

        raw_quantity = max_position_value / current_price
        quantity = max(self.min_shares_per_trade, int(raw_quantity))

        if quantity < 1:
            return 0, (
                f"calculated quantity < 1 (price=${current_price:.2f}, equity=${available_capital:.2f}, "
                f"budget=${max_position_value:.2f}, pct={position_size_pct:.4f})"
            )

        return quantity, None

    def strategy_to_trade_idea(self, strategy: TradeStrategy) -> TradeIdea:
        """Convert TradeStrategy to TradeIdea for execution.

        Args:
            strategy: Generated TradeStrategy

        Returns:
            TradeIdea compatible with existing execution system
        """
        direction = DirectionEnum.LONG if strategy.direction == "LONG" else DirectionEnum.SHORT

        # For options, the "symbol" in TradeIdea might need to be the option symbol
        # But TradeIdea might not support options fields.
        # We'll use the underlying symbol and rely on the execution engine to check the strategy object
        # or we overload the symbol if the system supports it.
        # Ideally TradeIdea schema should be updated, but for now we pass the strategy object directly in UnifiedTradingBot

        return TradeIdea(
            symbol=strategy.symbol,
            direction=direction,
            confidence=strategy.confidence,
            entry_price=strategy.entry_price,
            size=strategy.quantity
            * strategy.entry_price
            * (100 if strategy.asset_class == "option" else 1),
            reasoning=strategy.reasoning,
            timestamp=strategy.timestamp,
            stop_loss=strategy.stop_loss_price,
            take_profit=strategy.take_profit_price,
            timeframe=strategy.timeframe,
        )

    def validate_strategy(
        self, strategy: TradeStrategy, current_positions: List[str], total_portfolio_value: float
    ) -> bool:
        """Validate strategy meets risk management rules.

        Args:
            strategy: Strategy to validate
            current_positions: List of symbols with open positions
            total_portfolio_value: Total portfolio value

        Returns:
            True if strategy passes validation
        """
        # Check if already in position
        # For options, check if we have position in underlying OR option
        # Simplified: check underlying symbol
        if strategy.symbol in current_positions:
            logger.warning(f"Already in position for {strategy.symbol}")
            return False

        # Check portfolio risk limit
        risk_pct = (
            (strategy.risk_amount / total_portfolio_value) if total_portfolio_value > 0 else 1.0
        )
        if risk_pct > self.max_portfolio_risk_pct:
            logger.warning(
                f"Strategy risk {risk_pct:.2%} exceeds max {self.max_portfolio_risk_pct:.2%}"
            )
            return False

        # Check minimum R:R ratio
        if strategy.risk_reward_ratio < 1.5:
            logger.warning(f"R:R ratio {strategy.risk_reward_ratio:.1f} below minimum 1.5")
            return False

        return True


__all__ = ["TradeAgentV3", "TradeStrategy"]
