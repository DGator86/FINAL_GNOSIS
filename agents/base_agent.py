from __future__ import annotations

"""Lightweight base classes for agent implementations."""
"""Shared agent utilities for advanced trading agents."""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, Optional

import numpy as np


@dataclass
class AgentSignal:
    """Structured signal emitted by an agent."""
    """Represents a trading signal generated by an agent."""

    agent_id: str
    timestamp: datetime
    signal_type: str
    confidence: float
    reasoning: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    position_size: Optional[float] = None


class BaseAgent:
    """Base class for agents that track configuration and state."""
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    reasoning: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)


class BaseAgent:
    """Base functionality shared by advanced trading agents."""

    def __init__(self, agent_id: str, config: Dict[str, Any]):
        self.agent_id = agent_id
        self.config = config
        self.state: Dict[str, Any] = {}

    def analyze(self, market_data: Dict[str, Any], features: Dict[str, Any]) -> AgentSignal:
        """Analyze inputs and produce an :class:`AgentSignal`."""

        raise NotImplementedError("analyze must be implemented by subclasses")

    def update_state(
        self, market_data: Dict[str, Any], execution_result: Optional[Dict[str, Any]] = None
    ) -> None:
        """Update internal state from market data and optional execution results."""

        raise NotImplementedError("update_state must be implemented by subclasses")
        self.logger = logging.getLogger(self.__class__.__name__)
        self.required_features = []
        self.state: Dict[str, Any] = {}
        self.performance_metrics: Dict[str, Any] = {}

    def validate_features(self, features: Dict[str, Any]) -> bool:
        """Validate that all required features are available."""
        missing = [f for f in self.required_features if f not in features]
        if missing:
            self.logger.warning("Missing features: %s", ", ".join(missing))
            return False
        return True

    def calculate_position_size(
        self, confidence: float, current_price: float, account_balance: float
    ) -> float:
        """Simple risk-based position sizing."""
        risk_budget = self.config.get("risk_per_trade", 0.01) * account_balance
        if current_price <= 0:
            return 0.0
        position = risk_budget / current_price
        return float(np.clip(position / account_balance, 0.0, 1.0) * confidence)

    def calculate_stop_loss(
        self, current_price: float, signal_type: str, volatility: float
    ) -> float:
        """Derive a stop loss anchored on recent volatility."""
        buffer = max(volatility, 1e-4) * self.config.get("stop_loss_volatility", 2.0)
        return current_price * (1 - buffer) if signal_type == "buy" else current_price * (1 + buffer)

    def calculate_take_profit(
        self, current_price: float, signal_type: str, confidence: float, volatility: float
    ) -> float:
        """Derive a take-profit level based on conviction and volatility."""
        buffer = max(volatility, 1e-4) * (self.config.get("take_profit_base", 2.5) * confidence)
        return current_price * (1 + buffer) if signal_type == "buy" else current_price * (1 - buffer)

    def log_signal(self, signal: AgentSignal) -> None:
        """Log generated signals for observability."""
        self.logger.info(
            "Signal %s | type=%s confidence=%.2f size=%s",
            signal.agent_id,
            signal.signal_type,
            signal.confidence,
            signal.position_size,
        )
